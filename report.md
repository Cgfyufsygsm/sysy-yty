# 编译原理课程实践报告：SysY-YTY 编译器

信息科学技术学院 2300013165 杨涛瑜

## 一、编译器概述

### 1.1 基本功能

本编译器基本具备如下功能：
1. 基于 LALRPOP 解析 SysY 源代码，构建 AST。
2. 生成 Koopa IR，并可输出 Koopa IR 或 RISC-V 汇编。
3. 支持函数、变量/常量、数组、if/else、while、break/continue、短路逻辑等语义。
4. 后端生成 MIR 并进行寄存器分配与必要的 spill。
5. 提供 IR 级优化（常量传播/CFG 简化/死代码删除/保守函数内联）与后端汇编窥孔优化。

### 1.2 主要特点

本编译器的主要特点是**语法与语义分层清晰**、**常量折叠与数组初始化统一处理**、**后端栈帧与指针访问兼容数组**。语法与语义分层清晰体现在 AST 与 IR 生成分离；常量折叠通过 `Fold/Eval` 在前端完成；数组初始化统一处理全局/局部与嵌套大括号；后端通过栈帧布局与指针标记保证 `getelemptr/getptr` 的正确访存。

## 二、编译器设计

### 2.1 主要模块组成

编译器由前端、后端与辅助模块组成：前端负责语法分析、AST 与 Koopa IR 生成；后端负责 Koopa IR 到 RISC-V 汇编翻译与栈帧布局；辅助模块包括 SysY 库函数声明与寄存器池管理。

### 2.2 主要数据结构

本编译器最核心的数据结构是前端 AST、符号表与上下文，以及后端栈帧与 MIR。前端使用 `SymbolTable` 维护多层作用域与全局函数/变量；`Context` 保存当前函数/基本块及循环栈信息；后端使用 `FrameLayout` 记录每个值在栈上的偏移与指针属性，并引入 `Reg/Inst/MachineFunction` 表示机器中间表示与虚拟寄存器（在进行寄存器分配优化时重构了后端并添加）。

```rust
pub struct Environment {
  pub table: SymbolTable,
  pub ctx: Context,
}
```

此外，为统一处理数组初始化，前端引入 `InitLike/InitIter` 以线性消费初始化项，支持嵌套大括号与扁平序列混用；后端通过 `ValueOffset { offset, is_ptr }` 标记 `getelemptr/getptr` 结果为指针，从而在 load/store 时采用不同访存策略；寄存器分配阶段维护虚拟寄存器信息与 spill 槽，并基于活跃集与干涉图完成着色。

在 `if...else...` 语句方面，为避免“悬挂 else”二义性，语法层采用 Matched/Unmatched 的分层规则，保证 else 绑定最近的 if。

### 2.3 主要设计考虑及算法选择

#### 2.3.1 符号表的设计考虑
符号表用 `Vec<HashMap<...>>` 维护作用域栈，进入/离开语句块时 push/pop；全局表单独维护函数与全局变量。常量以 `i32` 直接存储，变量/数组/指针以 Koopa `Value` 存储，便于常量折叠与地址计算。

#### 2.3.2 寄存器分配策略
后端先将 Koopa IR 降为含虚拟寄存器的 MIR，再进行寄存器分配。采用活跃性分析 + 干涉图着色：优先分配 `t0~t5` 与 `s0~s11`，`t6` 预留为大立即数/偏移展开的 scratch；跨 `call` 的 live-out 强制 spill，无法着色则插入 load/store 重新分配。函数根据实际使用到的 `s*` 保存/恢复，返回地址 `ra` 仍按需保存。

#### 2.3.3 采用的优化策略
前端实现常量折叠：`Fold/Eval` 在 AST 层将可计算表达式化简为常量；短路逻辑在 IR 中显式建块，避免无效求值。IR 优化阶段包含常量传播、CFG 简化、死代码删除与保守函数内联（仅对单基本块、无调用/跳转且指令数受限的函数内联）；后端加入寄存器分配与必要的 spill，并在汇编阶段做窥孔优化（同址 sw/lw 合并、跳转到下一标签消除、冗余 mv 删除）。

#### 2.3.4 其它补充设计考虑
数组访问采用“地址计算 + 退化(decay)”策略，指针与数组在 IR 上统一为指针类型；生成 IR 时维护 `terminated_bbs`，避免在已终止基本块继续插入指令；循环控制使用循环栈记录 `continue/break` 目标块，支持嵌套循环。

## 三、编译器实现

### 3.1 各阶段编码细节

#### Lv1. main函数和Lv2. 初试目标代码生成
`main` 使用 clap 解析 `-ast/-koopa/-riscv` 模式；前端用 LALRPOP 生成 AST，再生成 Koopa IR；`-koopa` 通过 `KoopaGenerator` 输出，`-riscv` 交给后端生成汇编。

#### Lv3. 表达式
语法层按 `LOrExp → LAndExp → EqExp → RelExp → AddExp → MulExp → UnaryExp` 建优先级；IR 层为一元/二元操作直接生成 `binary` 指令。

#### Lv4. 常量和变量
常量在符号表中保存 `i32`，表达式先做 `fold` 再生成 IR；全局变量与数组用 `global_alloc`/`aggregate` 初始化，局部变量先 `alloc` 再 `store`。

#### Lv5. 语句块和作用域
块级语句进入/退出时维护作用域栈，保证局部变量遮蔽与生命周期正确；`Context` 记录当前基本块，遇到终止指令会标记并停止继续插入。

#### Lv6. if语句
根据是否有 else 生成 then/else/end 三段控制流；若分支均终止则不再创建合并块。

#### Lv7. while语句
生成 entry/body/end 三个基本块；entry 负责条件判断并分支；body 末尾回跳 entry；通过循环栈保存 `continue` 与 `break` 的目标块，支持嵌套。

#### Lv8. 函数和全局变量
函数签名使用 Koopa `FunctionData` 构造，参数落栈后再进入局部作用域；内置 SysY 函数在前端初始化阶段插入符号表；后端按 ABI 处理参数与返回值。

在处理栈帧时写了一个很难察觉的 bug：栈上传入参数的偏移算重了一个 outgoing_args_size。对于 `many_params_2` 样例出现问题，即当一个有很多参数的函数调用另一个很多参数的函数时出现问题，后面进行了修复。

#### Lv9. 数组
数组类型由 `Type::get_array` 递归构建，多维数组按“外层数组 + 元素数组”建模；访问时通过 `getelemptr/getptr` 逐层计算地址，并在需要时做指针退化。数组初始化支持嵌套与扁平形式（这部分坑还有点大，对于 `int a[2][3] = {1, {2, 3}, 4}` 型的处理），并区分全局/局部生成方式。

### 3.2 工具软件介绍（若未使用特殊软件或库，则本部分可略过）
1. `lalrpop`：定义 SysY 语法并自动生成解析器。
2. `koopa`：构造与输出 Koopa IR，并提供 IR 结构操作。
3. `clap/once_cell`：命令行解析与全局寄存器池管理。

### 3.3 测试情况说明

能通过在线平台所有测试点的测试（包括 Koopa IR 和 RISCV）。

## 四、实习总结

### 4.1 收获和体会

在暑假时提前写了这个 lab，第一次用 Rust 写项目，感受到了 Rust 语言的魅力。同时通过写这个 lab 对编译器的流程有了更深刻的理解，助力了我在学期中的学习。

### 4.2 学习过程中的难点，以及对实习过程和内容的建议

Lab 完成并无明显难点，但课上学习自动机/正则表达式、LR(1)、SDT 等较为抽象的内容时遇到了一些困难。
